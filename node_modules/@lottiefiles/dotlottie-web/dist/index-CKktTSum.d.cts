interface Marker {
    duration: number;
    name: string;
    time: number;
}

/**
 * Represents the different types of events that can be dispatched.
 */
type EventType = 'complete' | 'frame' | 'load' | 'loadError' | 'loop' | 'pause' | 'play' | 'stop' | 'destroy' | 'freeze' | 'unfreeze' | 'render' | 'ready';
/**
 * Maps an event type string to its respective event interface.
 */
type EventByType<T> = T extends 'complete' ? CompleteEvent : T extends 'frame' ? FrameEvent : T extends 'load' ? LoadEvent : T extends 'loadError' ? LoadErrorEvent : T extends 'loop' ? LoopEvent : T extends 'pause' ? PauseEvent : T extends 'play' ? PlayEvent : T extends 'stop' ? StopEvent : T extends 'destroy' ? DestroyEvent : T extends 'freeze' ? FreezeEvent : T extends 'unfreeze' ? UnfreezeEvent : T extends 'render' ? RenderEvent : T extends 'ready' ? ReadyEvent : never;
/**
 * Base interface for all events.
 */
interface BaseEvent {
    type: EventType;
}
interface RenderEvent extends BaseEvent {
    currentFrame: number;
    type: 'render';
}
interface FreezeEvent extends BaseEvent {
    type: 'freeze';
}
interface UnfreezeEvent extends BaseEvent {
    type: 'unfreeze';
}
interface DestroyEvent extends BaseEvent {
    type: 'destroy';
}
/**
 * Event fired when a loop action occurs.
 */
interface LoopEvent extends BaseEvent {
    loopCount: number;
    type: 'loop';
}
/**
 * Event fired during frame changes.
 */
interface FrameEvent extends BaseEvent {
    currentFrame: number;
    type: 'frame';
}
/**
 * Event fired when a load action occurs.
 */
interface LoadEvent extends BaseEvent {
    type: 'load';
}
/**
 * Event fired when a loading error occurs.
 */
interface LoadErrorEvent extends BaseEvent {
    error: Error;
    type: 'loadError';
}
/**
 * Event fired when a completion action occurs.
 */
interface CompleteEvent extends BaseEvent {
    type: 'complete';
}
/**
 * Event fired when a pause action occurs.
 */
interface PauseEvent extends BaseEvent {
    type: 'pause';
}
/**
 * Event fired when a play action occurs.
 */
interface PlayEvent extends BaseEvent {
    type: 'play';
}
/**
 * Event fired when a stop action occurs.
 */
interface StopEvent extends BaseEvent {
    type: 'stop';
}
/**
 * Event fired when a WASM module is initialized and ready.
 */
interface ReadyEvent extends BaseEvent {
    type: 'ready';
}
/**
 * Type representing all possible event types.
 */
type Event = LoopEvent | FrameEvent | LoadEvent | LoadErrorEvent | CompleteEvent | PauseEvent | PlayEvent | StopEvent | DestroyEvent | FreezeEvent | UnfreezeEvent | RenderEvent | ReadyEvent;
interface EventListener<T extends EventType> {
    (event: EventByType<T>): void;
}
/**
 * Manages registration and dispatching of event listeners.
 */
declare class EventManager {
    private readonly _eventListeners;
    addEventListener<T extends EventType>(type: T, listener: EventListener<T>): void;
    removeEventListener<T extends EventType>(type: T, listener?: EventListener<T>): void;
    dispatch<T extends EventType>(event: EventByType<T>): void;
    removeAllEventListeners(): void;
}

interface RenderConfig {
    devicePixelRatio?: number;
}
type Mode = 'forward' | 'reverse' | 'bounce' | 'reverse-bounce';
type Data = string | ArrayBuffer | Record<string, unknown>;
type Fit = 'contain' | 'cover' | 'fill' | 'none' | 'fit-width' | 'fit-height';
interface Layout {
    align: [number, number];
    fit: Fit;
}
interface Config {
    autoplay?: boolean;
    backgroundColor?: string;
    canvas: HTMLCanvasElement;
    data?: Data;
    layout?: Layout;
    loop?: boolean;
    marker?: string;
    mode?: Mode;
    renderConfig?: RenderConfig;
    segment?: [number, number];
    speed?: number;
    src?: string;
    useFrameInterpolation?: boolean;
}
interface Manifest {
    activeAnimationId?: string;
    animations: Array<{
        autoplay?: boolean;
        defaultTheme?: string;
        direction?: 1 | -1;
        hover?: boolean;
        id: string;
        intermission?: number;
        loop?: boolean | number;
        playMode?: 'bounce' | 'normal';
        speed?: number;
        themeColor?: string;
    }>;
    author?: string;
    custom?: Record<string, unknown>;
    description?: string;
    generator?: string;
    keywords?: string;
    revision?: number;
    states?: string[];
    themes?: Array<{
        animations: string[];
        id: string;
    }>;
    version?: string;
}

interface DotLottieInstanceState {
    activeAnimationId: string | undefined;
    activeThemeId: string | undefined;
    autoplay: boolean;
    backgroundColor: string;
    currentFrame: number;
    duration: number;
    isFrozen: boolean;
    isLoaded: boolean;
    isPaused: boolean;
    isPlaying: boolean;
    isReady: boolean;
    isStopped: boolean;
    layout: Layout | undefined;
    loop: boolean;
    manifest: Manifest | null;
    marker: string | undefined;
    markers: Marker[];
    mode: Mode;
    renderConfig: RenderConfig;
    segment: [number, number] | undefined;
    segmentDuration: number;
    speed: number;
    totalFrames: number;
    useFrameInterpolation: boolean;
}
declare class DotLottieWorker {
    private static readonly _workerManager;
    private readonly _eventManager;
    private readonly _id;
    private readonly _worker;
    private readonly _canvas;
    private _dotLottieInstanceState;
    private static _wasmUrl;
    private _created;
    constructor(config: Config & {
        workerId?: string;
    });
    private _handleWorkerEvent;
    private _create;
    get isLoaded(): boolean;
    get isPlaying(): boolean;
    get isPaused(): boolean;
    get isStopped(): boolean;
    get currentFrame(): number;
    get isFrozen(): boolean;
    get segmentDuration(): number;
    get totalFrames(): number;
    get segment(): [number, number] | undefined;
    get speed(): number;
    get duration(): number;
    get isReady(): boolean;
    get mode(): Mode;
    get canvas(): HTMLCanvasElement | null;
    get autoplay(): boolean;
    get backgroundColor(): string;
    get loop(): boolean;
    get useFrameInterpolation(): boolean;
    get renderConfig(): RenderConfig;
    get manifest(): Manifest | null;
    get activeAnimationId(): string | undefined;
    get marker(): string | undefined;
    get activeThemeId(): string | undefined;
    get layout(): Layout | undefined;
    play(): Promise<void>;
    pause(): Promise<void>;
    stop(): Promise<void>;
    setSpeed(speed: number): Promise<void>;
    setMode(mode: Mode): Promise<void>;
    setFrame(frame: number): Promise<void>;
    setSegment(start: number, end: number): Promise<void>;
    setRenderConfig(renderConfig: RenderConfig): Promise<void>;
    setUseFrameInterpolation(useFrameInterpolation: boolean): Promise<void>;
    loadTheme(themeId: string): Promise<boolean>;
    load(config: Omit<Config, 'canvas'>): Promise<void>;
    setLoop(loop: boolean): Promise<void>;
    resize(): Promise<void>;
    destroy(): Promise<void>;
    freeze(): Promise<void>;
    unfreeze(): Promise<void>;
    setBackgroundColor(backgroundColor: string): Promise<void>;
    loadAnimation(animationId: string): Promise<void>;
    setLayout(layout: Layout): Promise<void>;
    private _updateDotLottieInstanceState;
    markers(): Marker[];
    setMarker(marker: string): Promise<void>;
    loadThemeData(themeData: string): Promise<boolean>;
    setViewport(x: number, y: number, width: number, height: number): Promise<boolean>;
    private _sendMessage;
    addEventListener<T extends EventType>(type: T, listener: EventListener<T>): void;
    removeEventListener<T extends EventType>(type: T, listener?: EventListener<T>): void;
    static setWasmUrl(url: string): void;
    loadStateMachine(stateMachineId: string): Promise<boolean>;
    loadStateMachineData(stateMachineData: string): Promise<boolean>;
    startStateMachine(): Promise<boolean>;
    stopStateMachine(): Promise<boolean>;
    postStateMachineEvent(event: string): Promise<boolean>;
    getStateMachineListeners(): Promise<string[]>;
    private _getPointerPosition;
    private _onPointerUp;
    private _onPointerDown;
    private _onPointerMove;
    private _onPointerEnter;
    private _onPointerLeave;
    private _onComplete;
    private _setupStateMachineListeners;
    private _cleanupStateMachineListeners;
}

export { type BaseEvent as B, type Config as C, type DestroyEvent as D, type EventType as E, type FreezeEvent as F, type Layout as L, type Manifest as M, type PauseEvent as P, type RenderConfig as R, type StopEvent as S, type UnfreezeEvent as U, type Mode as a, type EventListener as b, type Marker as c, type RenderEvent as d, type LoopEvent as e, type FrameEvent as f, type LoadEvent as g, type LoadErrorEvent as h, type CompleteEvent as i, type PlayEvent as j, type ReadyEvent as k, type Event as l, EventManager as m, type Data as n, type Fit as o, type DotLottieInstanceState as p, DotLottieWorker as q };
