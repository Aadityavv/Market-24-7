import { C as Config, L as Layout, M as Manifest, R as RenderConfig, a as Mode, E as EventType, b as EventListener, c as Marker } from './index-CKktTSum.cjs';
export { B as BaseEvent, i as CompleteEvent, n as Data, D as DestroyEvent, p as DotLottieInstanceState, q as DotLottieWorker, l as Event, m as EventManager, o as Fit, f as FrameEvent, F as FreezeEvent, h as LoadErrorEvent, g as LoadEvent, e as LoopEvent, P as PauseEvent, j as PlayEvent, k as ReadyEvent, d as RenderEvent, S as StopEvent, U as UnfreezeEvent } from './index-CKktTSum.cjs';

declare class DotLottie {
    private readonly _canvas;
    private _context;
    private readonly _eventManager;
    private _animationFrameId;
    private readonly _frameManager;
    private _dotLottieCore;
    private static _wasmModule;
    private _renderConfig;
    private _isFrozen;
    private _backgroundColor;
    constructor(config: Config);
    private _loadFromSrc;
    private _loadFromData;
    get activeAnimationId(): string | undefined;
    get activeThemeId(): string | undefined;
    get layout(): Layout | undefined;
    get marker(): string | undefined;
    get manifest(): Manifest | null;
    get renderConfig(): RenderConfig;
    get segment(): [number, number] | undefined;
    get loop(): boolean;
    get mode(): Mode;
    get isFrozen(): boolean;
    get backgroundColor(): string;
    get autoplay(): boolean;
    get useFrameInterpolation(): boolean;
    get speed(): number;
    get isReady(): boolean;
    get isLoaded(): boolean;
    get isPlaying(): boolean;
    get isPaused(): boolean;
    get isStopped(): boolean;
    get currentFrame(): number;
    get loopCount(): number;
    get totalFrames(): number;
    get duration(): number;
    get segmentDuration(): number;
    get canvas(): HTMLCanvasElement | OffscreenCanvas;
    load(config: Omit<Config, 'canvas'>): void;
    private _render;
    private _draw;
    play(): void;
    pause(): void;
    stop(): void;
    setFrame(frame: number): void;
    setSpeed(speed: number): void;
    setBackgroundColor(color: string): void;
    setLoop(loop: boolean): void;
    setUseFrameInterpolation(useFrameInterpolation: boolean): void;
    addEventListener<T extends EventType>(type: T, listener: EventListener<T>): void;
    removeEventListener<T extends EventType>(type: T, listener?: EventListener<T>): void;
    destroy(): void;
    freeze(): void;
    unfreeze(): void;
    resize(): void;
    setSegment(startFrame: number, endFrame: number): void;
    setMode(mode: Mode): void;
    setRenderConfig(config: RenderConfig): void;
    loadAnimation(animationId: string): void;
    setMarker(marker: string): void;
    markers(): Marker[];
    loadTheme(themeId: string): boolean;
    loadThemeData(themeData: string): boolean;
    setLayout(layout: Layout): void;
    setViewport(x: number, y: number, width: number, height: number): boolean;
    static setWasmUrl(url: string): void;
    loadStateMachine(stateMachineId: string): boolean;
    startStateMachine(): boolean;
    stopStateMachine(): boolean;
    private _getPointerPosition;
    private _onPointerUp;
    private _onPointerDown;
    private _onPointerMove;
    private _onPointerEnter;
    private _onPointerLeave;
    private _onComplete;
    /**
     * @experimental
     * @param event - The event to be posted to the state machine
     * @returns boolean - true if the event was posted successfully, false otherwise
     */
    postStateMachineEvent(event: string): boolean;
    getStateMachineListeners(): string[];
    private _setupStateMachineListeners;
    private _cleanupStateMachineListeners;
    loadStateMachineData(stateMachineData: string): boolean;
    animationSize(): {
        height: number;
        width: number;
    };
    setStateMachineBooleanContext(name: string, value: boolean): boolean;
    setStateMachineNumericContext(name: string, value: number): boolean;
    setStateMachineStringContext(name: string, value: string): boolean;
}

export { Config, DotLottie, EventListener, EventType, Layout, Manifest, Mode, RenderConfig };
